---
layout: post
title: "Dynamic Programming (Chinese)"
author: "Island"
mathjax: true
categories: MyNotes
tags: [algorithm, math]
---

[**Dynamic Programming**](https://en.wikipedia.org/wiki/Dynamic_programming) is both a mathematical optimization method and a computer programming method.

事实上有很多时候我们已经接触了动态规划问题，比如Dijkstra's算法、求斐波那契数列、背包问题。在我眼里其主要核心思想是将问题分解为重复的子问题，而这些子问题的解应当被合理的储存。            
比如在Fibonacci数列里面，就是将所有的已经算好的数列预先存起来，再去推算下一个。如此一来，虽然开辟了新的空间去储存，但是极大的减少了递归求解的时间消耗。

Reference: 
1. [夜深人静写算法（2）：动态规划](http://blog.jobbole.com/96364/)


# 动态规划的经典模型
## 线性模型
**例题1**  在一个夜黑风高的晚上，有n（n <= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。 

> [Solution](https://www.cnblogs.com/qionglouyuyu/p/5126573.html)：          
我们先将所有人按花费时间递增进行排序，假设前i个人过河花费的最少时间为opt[i]。        
首先看初始状态：opt[0]=0，opt[1]=T[1]， opt[2]=T[2]...        
再看最后状态：最后只可能有两种情况        
> - 情况1：岸这边只剩一个人。最后渡河会是1和i一起渡河。       
状态转移方程：opt[i] = opt[i-1] + T[1] + T[i]           
其中opt[i-1]是i-1个人在对岸最少时间，所以此时手电筒必定在对岸；T[1]是送手电筒回来的时间；T[i]是最后渡河时间。              
> - 情况2：岸这边只剩两个人。最后渡河会是1和2一起渡河。         
状态转移方程：opt[i] = opt[i-2] + T[1] + T[i] + T[2] + T[2]              
其中opt[i-2]是i-2个人在对岸最少时间，所以此时手电筒必定在对岸；T[1]是送手电筒回来的时间；T[i]是最后渡河时间（i为目前为止最后一个，所以必定比另一个人慢），第一个T[2]是送手电筒回来的时间；第二个T[2]是2和1一起渡河的时间。    
>- [这两种最后情况其实对应的是]：每个人可以选择与1一起渡河，也可以选择除1和2之外的一个人渡河。那么总的状态转移方程取这两者的最小值：
opt[i] = min{ opt[i-1] + T[1] + T[i] , opt[i-2] + T[1] + T[i] + 2*T[2] }

事实上这里说的比较晦涩，为了应用动态规划，我们应该首先确认：      
前i个人过河和前i-1, i-2个人过河有确定的关系吗？       
也就是需要确认我们是否真的可以通过前面得到的结果推得i个人的结果。原文在考虑将i号放在后置位过河的时候，并没有比较将i号放在前置位考虑时得到的时间结果。比如：先让1,2,3,4过河，再让5过河，就一定比先让1,2,5,3过河，再让4过河更省时间吗？先让1,2,3,4过河，再让5,6过河，就一定比先让1,2,5,6过河，再让3,4过河更省时间吗？

> 我们来先给出一个断言：          
> 在最短时间过河的情况下，最短时间只和三个因素有关，即1重复过河的次数、2重复过河的次数、3及以后的人是组合过河还是和1一起过河。

为了传递光源，我们需要一个人来回。那么这个人时间应当越短越好，就比如1和2是合适的，1又比2更为合适。也就是说，除了1和2，剩下的所有人都应当是只需要过去不需要回来，故而**1和2重复过河的次数是与最终结果相关的**。      

接着考虑以下情况，A-1 / B-2 / C-3 / D-4：     
i) T[1] = 1, T[2] = 2, T[3] = 5, T[4] = 7;         
ii)T[1] = 1, T[2] = 5, T[3] = 5, T[4] = 5.

对于第一种情况最优解为：
```cpp
ABCD	|    null
       ->AB         [B]
CD      |    AB
       <-A          [A]
       ->CD         [D]
A       |    BCD
       <-B          [B]
       ->AB         [B]
null    |    ABCD

Sum = B + A + D + B + B = 14
```
对于第二中情况最优解为：
```cpp
ABCD	|    null
       ->AB         [B]
CD      |    AB
       <-A          [A]
       ->AC         [C]
D       |    ABC
       <-A          [A]
       ->AD         [D]
null    |    ABCD

Sum = B + A + C + A + D = 17
```
由此我们也可以看出，CD（即不是最短、次短过河时间的人）过河的方式和B过河的时间有关。当一个组合C与D，若T[3] + T[1] > 2T[2]，则应该选择CD一起过河的方式；若T[3] + T[1] < 2T[2]，则应当选择C与A过河，D与A过河的分开过河方式；若T[3] + T[1] = 2T[2]，则两者均可。         
同时我们理应注意到，除去1和2，**剩余的所有人均只需要过河一次**。
那么对于满足T > 2T[2] - T[1]的人，应当选择合适的组合过河，而不满足条件的可以直接与A过河。      

由此我们可以将这些人分类：在每个人过河的时间根据序号依次递增的假设下，我们可以理解为越靠后面的人越倾向于与更后面的人组合过河。可以找到一个分界线，不妨记为X，有T[3], T[4], ..., T[X-1]比起与任意其他人组合过河来，更适合与1(A)过河；而T[X], ..., T[N]更适合选择一个组合一起过河。      
对于T[X], ..., T[N]应当选择何种组合的结论是明显的，因为组合过河的时间为A+D+B+B，故其受组合中过河时间**更慢**的人的限制，所以最小过河时间的组合应是从T[N]开始往前组合，即T[N]与T[N-1], T[N-2]与T[N-3]等相邻的组合方式。对于T[X]，视其是否有组合决定其过河方式。      

确定完组合后的过河顺序是不重要的，**至此，对于给定的人数和对应过河时间，我们已经可以确定过河的最短时间**。        
为了应用动态规划，我们首先根据组合之前提到的规律，可以调整过河顺序，使3, 4, ..., N按顺序过河，如此我们就可以回答之前的问题：
> 前i个人过河和前i-1, i-2个人过河可以有确定的关系。      
但是先让1,2,3,4过河，再让5过河，不一定比先让1,2,5,3过河，再让4过河更省时间；先让1,2,3,4过河，再让5,6过河，也不一定比先让1,2,5,6过河，再让3,4过河更省时间。      
他们可能都是消耗同样的时间，因为确定完组合以后过河的先后顺序是不重要的，我们可以调整过河的顺序使之可以应用动态规划。

如此继续，我们就可以根据结论给出的讨论得到相应的状态转移方程。即：
- 若T[i-1] > 2T[2] - T[1]，那么i-1当是与i一同过河，最短过河时间为opt[i] = opt[i-2] + T[1] + T[i] + T[2] + T[2]；
- 若T[i-1] <= 2T[2] - T[1]，那么i-1当是与1一起过河，最短过河时间为opt[i] = opt[i-1] + T[1] + T[i]。

故而我们得出opt[i] = min{ opt[i-1] + T[1] + T[i] , opt[i-2] + T[1] + T[i] + 2*T[2] }（事实上，在读入的T[i] >  2T[2] - T[1]以后，基本已经可以确定opt[i] = opt[i-2] + T[1] + T[i] + T[2] + T[2]）。

## 区间模型