---
layout: post
title: "Dynamic Programming (Chinese)"
author: "Island"
mathjax: true
categories: MyNotes
tags: [algorithm, math]
---

[**Dynamic Programming**](https://en.wikipedia.org/wiki/Dynamic_programming) is both a mathematical optimization method and a computer programming method.

事实上有很多时候我们已经接触了动态规划问题，比如Dijkstra's算法、求斐波那契数列、背包问题。在我眼里其主要核心思想是将问题分解为重复的子问题，而这些子问题的解应当被合理的储存。            
比如在Fibonacci数列里面，就是将所有的已经算好的数列预先存起来，再去推算下一个。如此一来，虽然开辟了新的空间去储存，但是极大的减少了递归求解的时间消耗。

Reference: 
1. [夜深人静写算法（2）：动态规划](http://blog.jobbole.com/96364/)


# 动态规划的经典模型
## 线性模型
**例题1**  在一个夜黑风高的晚上，有n（n <= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。 

[Solution](https://www.cnblogs.com/qionglouyuyu/p/5126573.html)：          
我们先将所有人按花费时间递增进行排序，假设前i个人过河花费的最少时间为opt[i]。        
首先看初始状态：opt[0]=0，opt[1]=T[1]， opt[2]=T[2]...        
再看最后状态：最后只可能有两种情况        
- 情况1：岸这边只剩一个人。最后渡河会是1和i一起渡河。       
状态转移方程：opt[i] = opt[i-1]+T[1]+T[i]           
其中opt[i-1]是i-1个人在对岸最少时间，所以此时手电筒必定在对岸；T[1]是送手电筒回来的时间；T[i]是最后渡河时间。              
- 情况2：岸这边只剩两个人。最后渡河会是1和2一起渡河。         
状态转移方程：opt[i] = opt[i-2]+T[1]+T[i]+T[2]+T[2]              
其中opt[i-2]是i-2个人在对岸最少时间，所以此时手电筒必定在对岸；T[1]是送手电筒回来的时间；T[i]是最后渡河时间（i为目前为止最后一个，所以必定比另一个人慢），第一个T[2]是送手电筒回来的时间；第二个T[2]是2和1一起渡河的时间。                

这两种最后情况其实对应的是：每个人可以选择与1一起渡河，也可以选择除1和2之外的一个人渡河。那么总的状态转移方程取这两者的最小值：
opt[i] = min{ opt[i-1] + T[1] + T[i] , opt[i-2] + T[1] + T[i] + 2*T[2] }

事实上这里说的比较晦涩，为了应用动态规划，我们应该首先确认：      
前i个人过河和前i-1, i-2个人过河有确定的关系吗？       
也就是需要确认我们是否真的可以通过前面得到的结果推得i个人的结果。原文在考虑将i号放在后置位过河的时候，并没有比较将i号放在前置位考虑时得到的时间结果。比如：先让1,2,3,4过河，再让5过河，就一定比先让1,2,5,3过河，再让4过河更省时间吗？先让1,2,3,4过河，再让5,6过河，就一定比先让1,2,5,6过河，再让3,4过河更省时间吗？
