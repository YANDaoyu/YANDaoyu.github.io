---
layout: post
title: "Marks of LeetCode: Top 100 liked Questions (in Algorithms)"
author: "Island"
mathjax: true
categories: MyNotes
tags: [Cplusplus]
---

From 15th, Oct, 2018 to ...


## 002. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/description/)

> You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.   
>You may assume the two numbers do not contain any leading zero, except the number 0 itself.


```cpp
/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {  
    ListNode *head = NULL, *prev = NULL;
    int carry = 0;

    while (l1 || l2) {
        int v1 = l1? l1->val: 0;
        int v2 = l2? l2->val: 0;
        int tmp = v1 + v2 + carry;
        carry = tmp / 10;
        int val = tmp % 10;


        ListNode* cur = new ListNode(val);
        /* Step3: create a newcur */
        if (!head) head = cur;
        /* Step1: head->next = NULL */
        if (prev) prev->next = cur;
        /* Step4: cur->next = head->cur = newcur */
        prev = cur;
        /* Step2: prev = cur = head */


        l1 = l1? l1->next: NULL;
        l2 = l2? l2->next: NULL;
    }
    if (carry > 0) {
        ListNode* l = new ListNode(carry);
        prev->next = l;
    }
    return head;
}
};
```
Forgot necessary knowledges about **structure** and **point** and **linked list**. Besides, define a function in structure as `ListNode(int x)` is very common, but the operation `new ListNode(val)` may be not necessarily. If you want to create a structure dynamic,  and be able to delete whenever you want, you should use `new`.   
Created `new` in `heap` or `stack`?    
Only have a comparable ambiguous understanding of these stuffs. TuT.


## 004. [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/description/)

>There are two sorted arrays **nums1** and **nums2** of size $m$ and $n$ respectively.   
>Find the median of the two sorted arrays. The overall run time complexity should be $O(log (m+n))$.   
>You may assume **nums1** and **nums2** cannot be both empty.

Noted that: 
1. these two arrays are sorted.  
So combine them and then sort them may not be a good idea. At least it will cost $O(m+n)$ when scan the whole array.

2. the time complexity is $O(log(m+n))$.  
When it controlled by $log$, it definitely a mark of **binary** search!

Consider an algorithm designed to find the **Kth** number in two arrays.     
If the two arrays are long enough, then it is possible to discard **K/2** members each time:     
* Mark the arrays as A and B, then compare A[K/2] and B[K/2].     
* If A[K/2] > B[K/2], then discard the members before K/2+1 in B.

```cpp
class Solution {
public:
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    unsigned long length;
    length = nums1.size() + nums2.size();
    int left = (int)(length + 1) / 2;
    int right = (int)(length + 2) / 2;
    return (getKth(nums1, 0, (int)nums1.size() - 1, nums2, 0, (int)nums2.size() - 1, left) * 0.5 + getKth(nums1, 0, (int)nums1.size() - 1, nums2, 0, (int)nums2.size() - 1, right) * 0.5);
}
private:
int getKth(vector<int>& nums1, int start1, int end1, vector<int>& nums2, int start2, int end2, int k)
{
    int len1 = end1 - start1 + 1;
    int len2 = end2 - start2 + 1;

    if(len1 > len2)
        return getKth(nums2, start2, end2, nums1, start1, end1, k);

    if(len1 == 0)
        return nums2.at(start2 + k-1);

    if(k == 1)
        return min(nums1.at(start1), nums2.at(start2));

    int i = start1 + min(k/2, len1) - 1;
    int j = start2 + min(k/2, len2) - 1;
    if(nums1.at(i) > nums2.at(j))
        return getKth(nums1, start1, end1, nums2, j+1, end2, k - min(k/2,len2));
    else return getKth(nums1, i+1, end1, nums2, start2, end2, k - min(k/2, len1));
}
};
```

And if you need illustrations, here is a Chinese [reference](http://windliang.cc/2018/07/18/leetCode-4-Median-of-Two-Sorted-Arrays/)(part 6, don't contain Chinese in illustrations). In the reference, it also give another algorithm(part 8) that time complexity is $O(log(min(m, n)))$.

## 010. [Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/description/)

>Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'`.       
>`'.'` Matches any single character.       
>`'*'` Matches zero or more of the preceding element.       
>The matching should cover the **entire** input string (not partial).       

My explanation: (The example of the problem given in web is right, but their explanations are somehow wrong, in my view.)`'*'`can be use as a delete to the previous character, and if `s = "ab"`, `p = "kcab"`, the return value will be `false`,; if `s = "ab"`, `p = "c*ab"`, the return value will be `true`. (Actually I totally have no idea about this problem at the very beginning.TuT)

It's a **Dynamic Programming** problem. And you can refer [this](https://leetcode.com/problems/regular-expression-matching/discuss/5684/9-lines-16ms-C++-DP-Solutions-with-Explanations).
Define `P[i][j]` to represent the situation of whether `s[0..i)` matches `p[0..j)`, and then the `P[i][j]` can be decide by the previous `P[][]`.             
Consider the char in `p[j-1]`:           
1. When `p[j-1] != '*'`, then `P[i][j]` will be `true` only if `P[i-1][j-1] == true` and (`p[j-1] == s[i-1]` or `p[j-1] == '.'`).        
2. When `p[j-1] == '*'`, and the previous character doesn't repeat(which equals a deletion), then `P[i][j]` will be `true` only if `P[i][j-2] == true`.
3. When `p[j-1] == '*'`, and the previous character repeats at least once, then `P[i][j]` will be `true` only if `P[i-1][j] == true` (equals `P[i-1][j-2] == true`) and (`s[i-1] == p[j-2]` or `p[j-2] == '.'`).

```cpp
class Solution {
public:
bool isMatch(string s, string p) {
    int m = (int)s.length();
    int n = (int)p.length();
    vector<vector<bool> > dp(m + 1, vector<bool> (n + 1, false));

    dp[0][0] = true;
    for (int i = 0; i <= m; i++)
        for (int j = 1; j <= n; j++)
            if (p[j - 1] == '*')
                dp[i][j] = dp[i][j - 2] || (i > 0 && (s[i - 1] == p[j - 2] || p[j - 2] == '.') && dp[i - 1][j]);
            else dp[i][j] = i > 0 && dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '.');
    return dp[m][n];
}
};
```

BTW, `'*'` won't appear in the beginning. And English is quite an obstacle for me in processing the problems. :) *****.

## 15. [3Sum](https://leetcode.com/problems/3sum/description/)

>Given an array `nums` of *n* integers, are there elements *a, b, c* in `nums` such that *a + b + c = 0*? Find all unique triplets in the array which gives the sum of zero.

Time limit is very strick. The time complexity should better than $O(n^2)$. We need to avoid duplicates before push the combination into vector, and `find` function is time comsuming.

```cpp
sort(nums.begin(), nums.end());
    
for(int i =0; i < nums.size();){
    int start = i+1, end = nums.size()-1;
    // this is somehow important

    while(start < end){
        if(nums[i]+nums[start]+nums[end] == 0){
            rtn.push_back({nums[i],nums[start],nums[end]});
            start++; end--;
            while( (start < end) && nums[start] == nums[start-1] ) start++;
            while( (start < end) && nums[end] == nums[end+1] ) end--;

        }else if(nums[i]+nums[start]+nums[end] < 0){
            start++;
            while( (start < end) && nums[start] == nums[start-1] ) start++;
        }else{ // nums[i]+nums[start]+nums[end] > 0
            end--;
            while( (start < end) && nums[end] == nums[end+1] ) end--;
        }
    }
    
    i++;
    while( (i < nums.size()) && nums[i] == nums[i-1] ) i++;
    
}
```


## 33. [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)

Normal. Solve it by considering 4 situations under the control of `begin` and `end`.

## 34. [Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

> Given an array of integers `nums` sorted in ascending order, find the starting and ending position of a given `target` value.        
> Your algorithm's runtime complexity must be in the order of $O(log n)$.          
> If the target is not found in the array, return `[-1, -1]`.

The algorithm of this problem is quit easy.
And I just want to emphasis part of the algorithm:

```cpp
if(nums[begin] == target)
{
    result.push_back(begin);
    while(begin < end)
    {
        int medium = (begin + end) / 2;
        if(nums[medium] > target)
            end = medium-1;
        else begin = medium+1; 
        // nums[medium] = target
    }
    if(nums[begin] > target) result.push_back(begin-1);
    else result.push_back(begin);
    return result;
}
```

In this part, it only consider the situation that an array begin with the target.      
For example, if the `nums[4] = {2,2,2,4}, target = 2`.        
1st iteration, `medium = (0+3)/2 = 1`, and `nums[1] = 2 = target`, then `begin = 1+1 = 2`.          
2nd iteration, `medium = (2+3)/2 = 2`, and `nums[2] = 2 = target`, then `begin = 2+1 = 3`.               
Break the iteration with `begin = end = 3`.       
If  the `nums[4] = {2,3,4,5}, target = 2`.
1st iteration, `medium = (0+3)/2 = 1`, and `nums[1] = 3 > target`, then `end = 1-1 = 0`.       
Break the iteration with `begin = end = 0`.          
From the two cases, we can see that the result of the iteration may not exactly end in the point we want, but very near, often just in neighbours. 

That caused by the **last step** before the end of iteration: if the last run the `begin = medium+1`, then the `nums[begin]` will be bigger than target, else won't. So we add one more `if-else` to fine the result.

## 42. [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)

> Given *n* non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

![The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

Use mathematics to solve this kind of problems! The aim is to calculate the area of `blue`.      
First, find `biggest` and `smallest` integer of the array, then minus operation level by level. By doing this, we can gain the area of `black+blue`.         
The detail of minus is: find the `head` and `tail` of the array that no bigger than `some_integer`, and then `trapwater -= (head+tail)`.       
And the corresponding code is:

```cpp
for(int i = *min; i <= *max; i++ )
{
    int head, tail;
    int j;
    for(j = 0; j < size && height[j] < i; j++){}
    head = j;
    
    for(j = size - 1; j >= 0 && height[j] < i; j--){}
    tail = size - 1 - j;
    trapwater -= (head+tail);
}
```

Second, we calculate the area of `black`. It can be done by simply add all the interger of given array together.        
And then the result is easy to find, I guess. :)

## 46. [Permutations](https://leetcode.com/problems/permutations/)

> Given a collection of **distinct** integers, return all possible permutations.

A typical backtracking problem, solve the problem with a recursive solution.

## 48. [Rotate Image](https://leetcode.com/problems/rotate-image/)

> You are given an n x n 2D matrix representing an image.      
> Rotate the image by 90 degrees (clockwise).        
> **Note**:      
> You have to rotate the image **in-place**, which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.

Well, still can be solove by somehow.. an intuition.     
We need to gain a matirx `A` that satisfies `A[j][n-i-1] = R[i][j]`, where `R` is the raw given matrix.      
And the corresponding code is:

```cpp
reverse(matrix.begin(), matrix.end());
for (int i = 0; i < matrix.size(); ++i) {
    for (int j = i + 1; j < matrix[i].size(); ++j)
        swap(matrix[i][j], matrix[j][i]);
}
```

First, we reverse rows of the matrix, and after this operation we have `B[n-i-1][j] = R[i][j]`.        
Then, we exchange the row index and column index. That means `A[j][n-i-1] = B[n-i-1][j] = R[i][j]`. That's what we want.

## 49. [Group Anagrams](https://leetcode.com/problems/group-anagrams/)

> Given an array of strings, group anagrams together.

Let's first have a look on `unordered_map`: [Unordered map](https://en.cppreference.com/w/cpp/container/unordered_map) is an associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity.       
So the operation `m.second` means to get the value of the element in this unordered map, btw, `m.first` means to get the key of the element.

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, multiset<string>> mp;
        for (string s : strs) {
            string t = strSort(s);
            mp[t].insert(s);
        }
        vector<vector<string>> anagrams;
        for (auto m : mp) { 
            vector<string> anagram(m.second.begin(), m.second.end());
            anagrams.push_back(anagram);
        }
        return anagrams;
    }
private:
    string strSort(string& s) {
        int count[26] = {0}, n = s.length();
        for (int i = 0; i < n; i++)
            count[s[i] - 'a']++;
        int p = 0;
        string t(n, 'a');
        for (int j = 0; j < 26; j++)
            for (int i = 0; i < count[j]; i++)
                t[p++] += j;
        return t;
    } 
};
```

Actually the algorithm is very easy to understand, and it conrols the time complexity of sort to $O(n)$ rather than normal $O(nlog(n))$.

## 53. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

> Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Classic **Dynamic Programming** problem, we can use Kadane's algorithm to solve it.        
That is, scan from `nums`, and for each element in this array, set `dp[i]` to be the sum of a contiguous subarray that ends with `nums[i]` and has the max sum.      
Then `dp[i+1]` = `dp[i] + nums[i+1]` or `nums[i+1]`.       
And the result can be represent as the max element in the `dp` array.

## 55. [Jump Game](https://leetcode.com/problems/jump-game/)
> Given an array of non-negative integers, you are initially positioned at the first index of the array.       
Each element in the array represents your maximum jump length at that position.          
Determine if you are able to reach the last index.

```cpp
bool canJump(vector<int>& nums) {
    int size=nums.size(), step=nums[0];
    for(int i = 1; i < size; ++i){
        if(step-- < 0)
           return false;
        if(nums[i] > step)
           step = nums[i];
    }
    return true;
}
```
Easy to understand, btw, `step` is the rest step it can take at the position, can be update by `nums[i]` if it bigger than the before record. The interation begins with `1`, and whenever the step is less than 0 and haven't reach the tail, it returns false.

## 56. [Merge Intervals](https://leetcode.com/problems/merge-intervals/)

> Given a collection of intervals, merge all overlapping intervals.

```cpp
sort(intervals.begin(), intervals.end(), 
[](Interval a, Interval b)
    {return a.start < b.start;} );
```
Well, I haven't saw this operation before, it looks like very useful!     
And after we sort the intervals, we do combination by comparing the its end and start till it have no overlap.

```cpp
int k = 0;
for(int i = 1; i < len; i++)
{
    if(intervals[i].start <= result[k].end)
        result[k].end = max(result[k].end, intervals[i].end);
    else{
        k++;
        result.push_back(intervals[i]);
    }
}
```

## 62. [Unique Paths](https://leetcode.com/problems/unique-paths/)

> A robot is located at the top-left corner of a *m x n* grid (marked 'Start' in the diagram below).         
The robot can only move **either down or right** at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).         
How many possible unique paths are there?

![Above is a 7 x 3 grid. How many possible unique paths are there?](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

From the description, we noted that the path that can reach the first row and the first column is **1**. And the other position's value can be caculate by adding its up and left value. That means `way[j][i] = way[j-1][i] + way[j][i-1]` if `i != 0 && j != 0`.        
Then the result can be represented as `way[m-1][n-1]`.       
(Actually it's a classic math problem in junior high school level.)


## 64. [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)

> Given a *m x n* grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.        
**Note**: You can only move either down or right at any point in time.

Still similar as before. Replace `way[j][i] = way[j-1][i] + way[j][i-1]` as `way[i][j] = min(way[i][j-1], way[i-1][j]) + grid[i][j]`.     
And return `way[m-1][n-1]`.


## 72. [Edit Distance](https://leetcode.com/problems/edit-distance/)

> Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.        
You have the following 3 operations permitted on a word:      
> 1. Insert a character
> 2. Delete a character
> 3. Replace a character

This problem can be applied in a real world, and edit distance also named **the Levenshtein Distance**.

Well, there is a [video](https://www.youtube.com/watch?v=MiqoA-yF-0M) that helps a lot in this problem. And here is the key:            
![key](https://ws2.sinaimg.cn/large/006tNc79gy1fzd33rtwdhj30yo0omtsj.jpg)
Or maybe you need more [reference](https://leetcode.com/problems/edit-distance/discuss/25846/20ms-Detailed-Explained-C++-Solutions-(O(n)-Space)).


## 75. [Sort Colors](https://leetcode.com/problems/sort-colors/)

> Given an array with *n* objects colored red, white or blue, sort them **in-place** so that objects of the same color are adjacent, with the colors in the order red, white and blue.      
Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.      
**Note**: You are not suppose to use the library's sort function for this problem.

```cpp
void sortColors(vector<int>& nums) {
    int R = 0, B = nums.size() - 1;
    for(int i = 0; i < B + 1;)
    {
        if(nums[i] == 0)
            swap(nums[i++], nums[R++]);
        else if(nums[i] == 2)
            swap(nums[i], nums[B--]);
        else i++;
    }
}
```
The result array is looks like: [0,0,1,1,2,2], means [red, red, white, white, blue, blue].
We store the index of `red` and `blue`, and ensure they can be put into the right place.        
When `nums[i] == 0`, then exchange it with `nums[R]` and `i++`, `R++`.           
As when `nums[i] == 2`, we won't do `i++` operation, and the `nums[R]` is behind `nums[i]`, so `nums[R]` can only be `0` or `1`.      
Here, whenever we do `swap(nums[i], nums[R])`, then `nums[i]` will be `0` or `1`, and the elements before R is `0`. Also we can know that the elements between `R` and `i` is `1`, the elements after `B` is `2`.    
Do the interation till `i` meets `B`, then all the array is be sorted.


## 76. [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

> Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity $O(n)$.

```cpp
for(auto c: t)  map[c]++;
int begin=0, end=0;
int d = INT_MAX, head = 0;
while(end < m){
    if(map[s[end]] > 0) 
        n--; 
    map[s[end]]--; end++;
    while(n == 0){ 
        if(end-begin < d) {
            d = end - begin;
            head = begin;
        }
        if(map[s[begin]] == 0) 
            n++;  
        map[s[begin]]++;begin++;
    }  
}
```

Here is the [official solution](https://leetcode.com/problems/minimum-window-substring/solution/) with explanation. **CLICK IT! IT'S BEAUTIFUL!**          
The hint is to use to point to control the window, and that's 
a normal operation in substring problem.
`d` is the length of the required substring, 
and `head` is the begin position of the substring.     
Whenever `n == 0`, it means the substring 
from `begin` to `end` contains `t`.        
If `map[s[begin]] == 0`, it means that if delete `s[begin]`, 
the substring wouldn't contain all the letter in `t`.     
Btw, the letter that `in_s` but `not_in_t` will never be greater than `0` (equals it won't lead to a `n--` operation),
and once it becomes `0`, it means that the elements between here to `end` won't contain this letter (equals it won't led to a `n++` operation).

## 78. [Subsets](https://leetcode.com/problems/subsets/)

> Given a set of **distinct** integers, nums, return all possible subsets (the power set).        
**Note**: The solution set must not contain duplicate subsets.

Obviously, a set of *n* distinct intergers will have 
$2^n - 1$ non-zero different sunsets.
They can be represent as '00000', '00001', '00010', and so on.
So we can do the interation from $1$ to $2^n - 1$(with their binaries)
to build these distinct subsets.

## 79. [Word Search](https://leetcode.com/problems/word-search/)

> Given a 2D board and a word, find if the word exists in the grid.      
The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Not interesting, use DFS to solve it.

## 84. [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)

> Given *n* non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.

I solved it with stupid interation.

And the [reference](https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/28905/My-concise-C%2B%2B-solution-AC-90-ms) tells a solution that the key is to drop all the integer that bigger that `hegihts[i]`:
```cpp
int largestRectangleArea(vector<int> &height) {
    int ret = 0;
    height.push_back(0);
    vector<int> index;
    
    for(int i = 0; i < height.size(); i++)
    {
        while(index.size() > 0 && height[index.back()] >= height[i])
        {
            int h = height[index.back()];
            index.pop_back();
            
            int sidx = index.size() > 0 ? index.back() : -1;
            if(h * (i-sidx-1) > ret)
                ret = h * (i-sidx-1);
        }
        index.push_back(i);
    }
    
    return ret;
}
```

## 85. [Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/)

> Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.

```cpp
int max = -1;
vector<int> heights(n);
for(int i = 0; i < m; i++){
    for(int j = 0; j < n; j++){
        if(matrix[i][j] == '0') heights[j] = 0;
        else heights[j]++;
    }
    // use the algorithm in Q84
    int tmax = largestRectangleArea(heights);
    if(tmax > max) max = tmax;
}
```

We acn gain the result by compare the rectangle level by level.      
Each time calculate the biggest rectangle from row `i` to `0`.

## 94/96/98/101/102/104: All About Trees

Just skip these easy problems~