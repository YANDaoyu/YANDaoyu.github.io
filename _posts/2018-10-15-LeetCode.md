---
layout: post
title: "Marks of LeetCode: Top 100 liked Questions (in Algorithms)"
author: "Island"
mathjax: true
categories: MyNotes
tags: [Cplusplus,note]
---

From 15th, Oct, 2018 to ...


## 002. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/description/)

> You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.   
>You may assume the two numbers do not contain any leading zero, except the number 0 itself.


```cpp
/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {  
ListNode *head = NULL, *prev = NULL;
int carry = 0;

while (l1 || l2) {
int v1 = l1? l1->val: 0;
int v2 = l2? l2->val: 0;
int tmp = v1 + v2 + carry;
carry = tmp / 10;
int val = tmp % 10;


ListNode* cur = new ListNode(val);  /* Step3: create a newcur */
if (!head) head = cur;              /* Step1: head->next = NULL */
if (prev) prev->next = cur;         /* Step4: cur->next = head->cur = newcur */
prev = cur;                         /* Step2: prev = cur = head */


l1 = l1? l1->next: NULL;
l2 = l2? l2->next: NULL;
}
if (carry > 0) {
ListNode* l = new ListNode(carry);
prev->next = l;
}
return head;
}
};
```
Forgot necessary knowledges about **structure** and **point** and **linked list**. Besides, define a function in structure as `ListNode(int x)` is very common, but the operation `new ListNode(val)` may be not necessarily. If you want to create a structure dynamic,  and be able to delete whenever you want, you should use `new`.   
Created `new` in `heap` or `stack`?    
Only have a comparable ambiguous understanding of these stuffs. TuT.


## 004. [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/description/)

>There are two sorted arrays **nums1** and **nums2** of size $m$ and $n$ respectively.   
>Find the median of the two sorted arrays. The overall run time complexity should be $O(log (m+n))$.   
>You may assume **nums1** and **nums2** cannot be both empty.

Noted that: 
1. these two arrays are sorted.  
So combine them and then sort them may not be a good idea. At least it will cost $O(m+n)$ when scan the whole array.

2. the time complexity is $O(log(m+n))$.  
When it controlled by $log$, it definitely a mark of **binary** search!

Consider an algorithm designed to find the **Kth** number in two arrays.     
If the two arrays are long enough, then it is possible to discard **K/2** members each time:     
* Mark the arrays as A and B, then compare A[K/2] and B[K/2].     
* If A[K/2] > B[K/2], then discard the members before K/2+1 in B.

```cpp
class Solution {
public:
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
unsigned long length;
length = nums1.size() + nums2.size();
int left = (int)(length + 1) / 2;
int right = (int)(length + 2) / 2;
return (getKth(nums1, 0, (int)nums1.size() - 1, nums2, 0, (int)nums2.size() - 1, left) * 0.5 +
getKth(nums1, 0, (int)nums1.size() - 1, nums2, 0, (int)nums2.size() - 1, right) * 0.5);
}
private:
int getKth(vector<int>& nums1, int start1, int end1, vector<int>& nums2, int start2, int end2, int k)
{
int len1 = end1 - start1 + 1;
int len2 = end2 - start2 + 1;

if(len1 > len2) return getKth(nums2, start2, end2, nums1, start1, end1, k);

if(len1 == 0) return nums2.at(start2 + k-1);

if(k == 1) return min(nums1.at(start1), nums2.at(start2));

int i = start1 + min(k/2, len1) - 1;
int j = start2 + min(k/2, len2) - 1;
if(nums1.at(i) > nums2.at(j))
return getKth(nums1, start1, end1, nums2, j+1, end2, k - min(k/2,len2));
else return getKth(nums1, i+1, end1, nums2, start2, end2, k - min(k/2, len1));
}
};
```

And if you need illustrations, here is a Chinese [reference](http://windliang.cc/2018/07/18/leetCode-4-Median-of-Two-Sorted-Arrays/)(part 6, don't contain Chinese in illustrations). In the reference, it also give another algorithm(part 8) that time complexity is $O(log(min(m, n)))$.

## 010. [Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/description/)

>Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'`.       
>`'.'` Matches any single character.       
>`'*'` Matches zero or more of the preceding element.       
>The matching should cover the **entire** input string (not partial).       

My explanation: (The example of the problem given in web is right, but their explanations are somehow wrong, in my view.)`'*'`can be use as a delete to the previous character, and if `s = "ab"`, `p = "kcab"`, the return value will be `false`,; if `s = "ab"`, `p = "c*ab"`, the return value will be `true`. (Actually I totally have no idea about this problem at the very beginning.TuT)

It's a **Dynamic Programming** problem. And you can refer [this](https://leetcode.com/problems/regular-expression-matching/discuss/5684/9-lines-16ms-C++-DP-Solutions-with-Explanations).
Define `P[i][j]` to represent the situation of whether `s[0..i)` matches `p[0..j)`, and then the `P[i][j]` can be decide by the previous `P[][]`.             
Consider the char in `p[j-1]`:           
1. When `p[j-1] != '*'`, then `P[i][j]` will be `true` only if `P[i-1][j-1] == true` and (`p[j-1] == s[i-1]` or `p[j-1] == '.'`).        
2. When `p[j-1] == '*'`, and the previous character doesn't repeat(which equals a deletion), then `P[i][j]` will be `true` only if `P[i][j-2] == true`.
3. When `p[j-1] == '*'`, and the previous character repeats at least once, then `P[i][j]` will be `true` only if `P[i-1][j] == true` (equals `P[i-1][j-2] == true`) and (`s[i-1] == p[j-2]` or `p[j-2] == '.'`).

```cpp
class Solution {
public:
bool isMatch(string s, string p) {
int m = (int)s.length();
int n = (int)p.length();
vector<vector<bool> > dp(m + 1, vector<bool> (n + 1, false));

dp[0][0] = true;
for (int i = 0; i <= m; i++)
for (int j = 1; j <= n; j++)
if (p[j - 1] == '*')
dp[i][j] = dp[i][j - 2] ||
(i > 0 && (s[i - 1] == p[j - 2] || p[j - 2] == '.')
&& dp[i - 1][j]);
else dp[i][j] = i > 0 && dp[i - 1][j - 1] &&
(s[i - 1] == p[j - 1] || p[j - 1] == '.');
return dp[m][n];
}
};
```

BTW, `'*'` won't appear in the beginning. And English is quite an obstacle for me in processing the problems. :) *****.

## 15. [3Sum](https://leetcode.com/problems/3sum/description/)

>Given an array `nums` of *n* integers, are there elements *a, b, c* in `nums` such that *a + b + c = 0*? Find all unique triplets in the array which gives the sum of zero.

Time limit is very strick. The time complexity should better than $O(n^2)$. We need to avoid duplicates before push the combination into vector, and `find` function is time comsuming.

```cpp
sort(nums.begin(), nums.end());
    
for(int i =0; i < nums.size();){
    int start = i+1, end = nums.size()-1;

    while(start < end){
        if(nums[i]+nums[start]+nums[end] == 0){
            rtn.push_back({nums[i],nums[start],nums[end]});
            start++; end--;
            while( (start < end) && nums[start] == nums[start-1] ) start++;
            while( (start < end) && nums[end] == nums[end+1] ) end--;

        }else if(nums[i]+nums[start]+nums[end] < 0){
            start++;
            while( (start < end) && nums[start] == nums[start-1] ) start++;
        }else{ // nums[i]+nums[start]+nums[end] > 0
            end--;
            while( (start < end) && nums[end] == nums[end+1] ) end--;
        }
    }
    
    i++;
    while( (i < nums.size()) && nums[i] == nums[i-1] ) i++;
    
}
```



## 33. [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)

Wrong Answer:  181/196

## 34. [Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

> Given an array of integers `nums` sorted in ascending order, find the starting and ending position of a given `target` value.        
> Your algorithm's runtime complexity must be in the order of $O(log n)$.          
> If the target is not found in the array, return `[-1, -1]`.

The algorithm of this problem is quit easy.
And I just want to emphasis part of the algorithm:

```cpp
if(nums[begin] == target)
{
result.push_back(begin);
while(begin < end)
{
int medium = (begin + end) / 2;
if(nums[medium] > target)
end = medium-1;
else begin = medium+1; // nums[medium] = target
}
if(nums[begin] > target) result.push_back(begin-1);
else result.push_back(begin);
return result;
}
```

In this part, it only consider the situation that an array begin with the target.      
For example, if the `nums[4] = {2,2,2,4}, target = 2`.        
1st iteration, `medium = (0+3)/2 = 1`, and `nums[1] = 2 = target`, then `begin = 1+1 = 2`.          
2nd iteration, `medium = (2+3)/2 = 2`, and `nums[2] = 2 = target`, then `begin = 2+1 = 3`.               
Break the iteration with `begin = end = 3`.       
If  the `nums[4] = {2,3,4,5}, target = 2`.
1st iteration, `medium = (0+3)/2 = 1`, and `nums[1] = 3 > target`, then `end = 1-1 = 0`.       
Break the iteration with `begin = end = 0`.          
From the two cases, we can see that the result of the iteration may not exactly end in the point we want, but very near, often just in neighbours. 

That caused by the **last step** before the end of iteration: if the last run the `begin = medium+1`, then the `nums[begin]` will be bigger than target, else won't.





















